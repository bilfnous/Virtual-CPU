/*
 * File:   execute.c
 * Author: B. Alfanous
 * Created on OCT 29, 2019
 */

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include "vcpu.h"

/*
		Continue implementing the execute stage of the CPU. 
		In particular, implement:
			a.the Load/Store instructions,
			b.the Stop instruction,
			c.the sign, zero and carry flag

			ADC  0101 Rd:= Rd+ Rn+ Cncz
*/


 /*
 *   iscarry()- determine if carry is generated by addition: op1+op2+C
 *   C can only have value of 1 or 0.
 */
int iscarry(unsigned long op1, unsigned long op2, unsigned C) {
	if ((op2 == MAX32) && (C == 1))
		return(1); // special case where op2 is at MAX32
	return((op1 > (MAX32 - op2 - C)) ? 1 : 0);
}

/* Function that help implement the load instruction*/
int loadReg(int mem_addr_reg, void* memory)
{
	int i;
	r_mem_addr_reg = mem_addr_reg;

	for (i = 0; i < CYCLES; i++, r_mem_addr_reg++)
	{
		r_mem_buff_reg = r_mem_buff_reg << SHIFT_BYTE;
		r_mem_buff_reg += *((unsigned char*)memory + r_mem_addr_reg);
	}

	return r_mem_buff_reg;
}

/* Function fetchs the inst from memory*/
void fetch(void* memory) {

	ir = loadReg(PC, memory);
	/* PC + 1 instruction */
	PC += REG_SIZE;
}

void execute(void* memory) {
	int i;

	if (LOAD_STORE)	{

		if (LOAD_BIT) {
			/*Load Byte*/
			if (BYTE_BIT) {
				registers[RD] = loadReg(registers[RN], memory);
				registers[RD] = registers[RD] & BYTE_MASK;
			}
			/*Load DWORD*/
			else {
				registers[RD] = loadReg(registers[RN], memory);
			}
		}
		else {
			r_mem_buff_reg = registers[RD];
			/*Store one byte of reg into memory*/
			if (BYTE_BIT) {
				r_mem_addr_reg = registers[RN];
				r_mem_buff_reg = registers[RD];
				*((unsigned char*)memory + r_mem_addr_reg) = (unsigned char)r_mem_buff_reg & BYTE_MASK;
			}
			/*Store DWORD*/
			else {

				for (i = CYCLES - 1; i >= 0; i--) {
					*((unsigned char*)memory + r_mem_addr_reg++) = (unsigned char)(r_mem_buff_reg >> SHIFT_BYTE * i& BYTE_MASK);
				}
			}
		}
	}

	/* Branch inst.*/
	else if (BRANCH)
	{
		/* Jumps to a specified location determined form the inst.*/
		if (LINK_BIT) {
			// set the return address in the link reg.
			LR = PC;
		}
		// set PC to offset determined from the inst.
		PC = OFFSET12;
		ir = 0;
	}
	/* Cond. Branch inst.*/
	else if (COND_BRANCH)
	{
		// check condition code
		if (checkbran()) {
			// setting alu to the result of PC + FF
			alu = PC + (int)COND_ADDR;
			// if IR1 !=0 pc will be pc + alu - 3 + 1 
			if (ir != 0) {

				ir = 0;
				alu = alu + ~THUMB_SIZE + 1;
			}
			// set PC to result of alu
			PC = alu;
		}
	}
	/* Data processing*/
	else if (DATA_PROC)
	{
		/* ADD inst.*/
		if (DATA_ADD) {
			alu = registers[RD] + registers[RN];
			flags(alu);
			f_carryFlag = iscarry(registers[RD], ~registers[RN], 0);
			registers[RD] = alu;
		}
		/* SUB inst.*/
		else if (DATA_SUB) {
			alu = registers[RD] + ~registers[RN] + 1;
			flags(alu);
			f_carryFlag = iscarry(registers[RD], ~registers[RN], 1);
			registers[RD] = alu;
		}
	}

	else if (STOP) {
		f_stopFlag = 1; // Setting the stop flag
	}



	* Function which determines the condition code suffixes for Cond. Branching*/
int checkbran(){
	// Equal is based on Zero flag = 1
	if (EQ){
		if (zeroFlag){
			return 1;
		}
	}
	// Not equal is based on Zero flag = 0
	else if (NE){

		if (zeroFlag == 0){
			return 1;
		}
	}
	// Higher or same based on carry = 1
	else if (CS){

		if (flag_carry){
			return 1;
		}
	}
	// Lower based on carry = 0
	else if (CC){

		if (!flag_carry){
			return 1;
		}
	}
	// Negative based on sign = 1
	else if (MI){

		if (signFlag){
			return 1;
		}
	}
	// Positive based on sign = 0
	else if (PL){

		if (!signFlag){
			return 1;
		}
	}
	// Higher based on carry = 1 and zero = 0
	else if (HI){

		if (flag_carry && zeroFlag == 0){
			return 1;
		}
	}
	// Lower based on carry = 0 or zero = 1
	else if (LS){

		if (flag_carry == 0 || zeroFlag){
			return 1;
		}
	}
	// Alaways is the default when no suffix specified 
	else if (AL){

		return 1;
	}

	return 0;
}




// Function which determines the condition code suffixes for Cond.Branching
int checkbran() {
	// Equal is based on Zero flag = 1
	if (EQ) {
		if (f_zeroFlag) {
			return 1;
		}
	}
	// Not equal is based on Zero flag = 0
	else if (NE) {

		if (f_zeroFlag == 0) {
			return 1;
		}
	}
	// Higher or same based on carry = 1
	else if (CS) {

		if (f_carryFlag) {
			return 1;
		}
	}
	// Lower based on carry = 0
	else if (CC) {

		if (!f_carryFlag) {
			return 1;
		}
	}
	// Negative based on sign = 1
	else if (MI) {

		if (f_signFlag) {
			return 1;
		}
	}
	// Positive based on sign = 0
	else if (PL) {

		if (!f_signFlag) {
			return 1;
		}
	}
	// Higher based on carry = 1 and zero = 0
	else if (HI) {

		if (f_carryFlag && f_zeroFlag == 0) {
			return 1;
		}
	}
	// Lower based on carry = 0 or zero = 1
	else if (LS) {

		if (f_carryFlag == 0 ||f_zeroFlag) {
			return 1;
		}
	}
	// Alaways is the default when no suffix specified 
	else if (AL) {

		return 1;
	}

	return 0;
}