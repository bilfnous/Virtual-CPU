/*
 * File:   execute.c
 * Author: B. Alfanous
 * Created on OCT 29, 2019
 */

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include "vcpu.h"

/*
		Continue implementing the execute stage of the CPU. 
		In particular, implement:
			a.the Load/Store instructions,
			b.the Stop instruction,
			c.the sign, zero and carry flag

			ADC  0101 Rd:= Rd+ Rn+ Cncz
*/


 /*
 *   iscarry()- determine if carry is generated by addition: op1+op2+C
 *   C can only have value of 1 or 0.
 */
int iscarry(unsigned long op1, unsigned long op2, unsigned C) {
	if ((op2 == MAX32) && (C == 1))
		return(1); // special case where op2 is at MAX32
	return((op1 > (MAX32 - op2 - C)) ? 1 : 0);
}

/* Function that help implement the load instruction*/
int loadReg(int mem_addr_reg, void* memory)
{
	int i;
	r_mem_addr_reg = mem_addr_reg;

	for (i = 0; i < CYCLES; i++, r_mem_addr_reg++)
	{
		r_mem_buff_reg = r_mem_buff_reg << SHIFT_BYTE;
		r_mem_buff_reg += *((unsigned char*)memory + r_mem_addr_reg);
	}

	return r_mem_buff_reg;
}

/* Function fetchs the inst from memory*/
void fetch(void* memory) {

	ir = loadReg(PC, memory);
	/* PC + 1 instruction */
	PC += REG_SIZE;
}

void execute(void* memory) {
	int i;

	if (LOAD_STORE)	{

		if (LOAD_BIT) {
			/*Load Byte*/
			if (BYTE_BIT) {
				registers[RD] = loadReg(registers[RN], memory);
				registers[RD] = registers[RD] & BYTE_MASK;
			}
			/*Load DWORD*/
			else {
				registers[RD] = loadReg(registers[RN], memory);
			}
		}
		else {
			r_mem_buff_reg = registers[RD];
			/*Store one byte of reg into memory*/
			if (BYTE_BIT) {
				r_mem_addr_reg = registers[RN];
				r_mem_buff_reg = registers[RD];
				*((unsigned char*)memory + r_mem_addr_reg) = (unsigned char)r_mem_buff_reg & BYTE_MASK;
			}
			/*Store DWORD*/
			else {

				for (i = CYCLES - 1; i >= 0; i--) {
					*((unsigned char*)memory + r_mem_addr_reg++) = (unsigned char)(r_mem_buff_reg >> SHIFT_BYTE * i& BYTE_MASK);
				}
			}
		}
	}
	else if (STOP) {
		f_stopFlag = 1; // Setting the stop flag
	}






}